#! /bin/bash
PROGNAME=$0

usage() {
  cat << EOF >&2
Usage: $PROGNAME -C <collection> -S <other server> [-bcsd]

 <collection>: The backed up collection that we want to compress
 <other server>: The server where the other half of the JSONLs are (probably either p86 or p90)

This script will create a compressed backup of the JSONLs for the specified <collection>, and 
then copy it to the <other server>. Afterwards it will delete the uncompressed data on both 
servers.

Example:
$PROGNAME -C SAWP1 -S p90.arquivo.pt

If any of the -b, -c, -s or -d flags are set, then it will only perfom the chosen subtasks:
(if none of these flags is set, it will perform all of them)

-b : Backup. Move JSONLs to the backups folder and download missing JSONLs from the other server.
-c : Compress. Compress the JSONLs that were put in the backups folder with the previous step.
-s : Synchronize. Copy the compressed backup generated by the previous step.
-d : Delete. Delete the non compressed files in both servers.

Example - Backup, compress and synchronize but not delete:
$PROGNAME -C SAWP1 -S p90.arquivo.pt -b -c -s

EOF
  exit 2
}

check() {
  # Mandatory fields:
  if [ -z "$COLLECTION" ] || [ -z "OTHER_SERVER" ]; then
    echo 'ERROR - Missing arguments'
    usage
  fi

  # Make sure we have the required dependencies:
  if ! pigz -h >/dev/null 2>/dev/null; then
    echo "ERROR - Dependency missing: Need to install pigz. Please run :"
    echo "  yum install pigz "
    echo "and run this script again afterwards."
    exit 1
  fi
}

backup() {
  echo "[BACKUP] - Starting backup step"

  HADOOP_FOLDER=/data/images/pipe # Where half of the JSONLs are on each server (output from hadoop + NSFW classifier)
  BACKUP_FOLDER=/data/images/to_backup/pipe # Where the backup is stored

  if [ ! -e $HADOOP_FOLDER/$COLLECTION ]; then
    echo "ERROR - $HADOOP_FOLDER/$COLLECTION : No such directory"
    exit 5
  fi

  if [ -e $BACKUP_FOLDER/$COLLECTION ]; then
    echo "ERROR - Collection already backed up on $BACKUP_FOLDER/$COLLECTION"
    exit 1
  fi

  echo "[BACKUP] - Copying $COLLECTION to backups folder..."
  mkdir $BACKUP_FOLDER/$COLLECTION

  # Moving local files to backup folder:
  find $HADOOP_FOLDER/$COLLECTION -mindepth 1 -maxdepth 1 -type d | rev | cut -d/ -f1 | rev | xargs -I {} mkdir $BACKUP_FOLDER/$COLLECTION/{}
  find $HADOOP_FOLDER/$COLLECTION -type f -name *.jsonl | rev | cut -d/ -f1-2 | rev | xargs -I {} cp $HADOOP_FOLDER/$COLLECTION/{} $BACKUP_FOLDER/$COLLECTION/{}

  echo "[BACKUP] - Checking that everything was copied..."

  INTEGRITY=$( (find $BACKUP_FOLDER/$COLLECTION -type f -name "*.jsonl" | rev | cut -d / -f 1-2 && find $HADOOP_FOLDER/$COLLECTION -type f -name "*.jsonl" | rev | cut -d / -f 1-2) | sort | uniq -u | rev )

  if [ ! -z "$INTEGRITY" ]; then
    echo "ERROR - Failed to correctly copy the files! Aborting."
    exit 1
  fi

# JSONLs are numbered. If they're split between p86 and p90, then one will have the evens and the other the odds.
#   This command checks the difference in two consecutive JSONLs, and stores it into STEP.
#   If STEP == 2, then we know that we need to get the other half from the other server.
  STEP=$(find $HADOOP_FOLDER/$COLLECTION -type f -name "*.jsonl" | rev | cut -d - -f1 | rev | cut -d _ -f1 | sort -r | head -n2 | tr '\n' '-' | cut -d - -f1-2 | bc)

  if [ "$STEP" -gt 1 ]; then
    echo "[BACKUP] - Missing half of the JSONL files! Fetching from $OTHER_SERVER... "
    LOCAL_JSONL_COUNT=$(find $HADOOP_FOLDER/$COLLECTION -type f -name "*.jsonl" | wc -l)
    find $HADOOP_FOLDER/$COLLECTION -mindepth 1 -maxdepth 1 -type d | rev | cut -d/ -f1 | rev | xargs -I {} scp -q "root@$OTHER_SERVER:$HADOOP_FOLDER/$COLLECTION/{}/*.jsonl" $BACKUP_FOLDER/$COLLECTION/{}

    if [ ! $? -eq 0 ]; then
      echo "Warning - Something went wrong. Retrying..."
      find $HADOOP_FOLDER/$COLLECTION -mindepth 1 -maxdepth 1 -type d | rev | cut -d/ -f1 | rev | xargs -I {} scp -q "root@$OTHER_SERVER:$HADOOP_FOLDER/$COLLECTION/{}/*.jsonl" $BACKUP_FOLDER/$COLLECTION/{}
    fi
    if [ ! $? -eq 0 ]; then
      echo "ERROR - Something went wrong while copying files from the other server! Aborting."
      exit 1
    fi

    FINAL_JSONL_COUNT=$(find $BACKUP_FOLDER/$COLLECTION -type f -name "*.jsonl" | wc -l)
    SUPPOSED_JSONL_COUNT=$(echo "2*$LOCAL_JSONL_COUNT" | bc)
    if [ ! "$FINAL_JSONL_COUNT" -eq "$SUPPOSED_JSONL_COUNT" ]; then
      echo "ERROR - Was expecting $SUPPOSED_JSONL_COUNT JSONL files, but found $FINAL_JSONL_COUNT instead. Aborting."
      exit 1
    fi

    echo "[BACKUP] - Files copied successfully!"
  fi
}

compress() {
  echo "[COMPRESS] - Starting compress step"
  BACKUP_FOLDER=/data/images/to_backup/pipe # Where the backup is stored
  INPUT_FOLDER=$(bash -c "find $BACKUP_FOLDER -mindepth 1 -maxdepth 1 -type d && echo $BACKUP_FOLDER/$COLLECTION" | sort | uniq -d)

  if [ -z "$INPUT_FOLDER" ]; then
    echo "ERROR - No collection named '$COLLECTION' found in $BACKUP_FOLDER. "
    exit 5
  fi

  cd $INPUT_FOLDER

  FOLDERS_TO_COMPRESS=$(find . -mindepth 1 -maxdepth 1 -type d | cut -d / -f 2-)
  if [ -z "$FOLDERS_TO_COMPRESS" ]; then
    echo "ERROR - Nothing to compress found on $INPUT_FOLDER. Contents of the folder:"
    ls -lh $INPUT_FOLDER
    exit 1
  fi

  echo "[COMPRESS] - Found the following folders to compress on $INPUT_FOLDER:"
  echo "$FOLDERS_TO_COMPRESS"

  echo "[COMPRESS] - Compressing..."
  find . -mindepth 1 -maxdepth 1 -type d | cut -d '/' -f 2- | xargs -I {} bash -c "tar cf - {} | pigz -9 -p 32 > {}.tar.gz"

  echo "[COMPRESS] - Checking that compression was successful..."

  INTEGRITY=$(find . -mindepth 1 -maxdepth 1 -type d | cut -d '/' -f 2- | xargs -I {} bash -c "find {}/ && pigz -dc -p 32 {}.tar.gz | tar -tf -" | sort | uniq -u)

  if [[ $(echo $INTEGRITY | sed s/\n// | sed s/\ //) != "" ]]; then
    echo "ERROR - Integrity check failed:"
    echo "$INTEGRITY"
    exit 1
  fi

  echo "[COMPRESS] - Compression successful! Removing original uncompressed files..."

  find . -mindepth 1 -maxdepth 1 -type d | xargs rm -rf

  echo "[COMPRESS] - Compression finished!"

}

sync() {
  echo "[SYNC] - Starting synchronization step"
  BACKUP_FOLDER=/data/images/to_backup/pipe # Where the backup is stored

  echo "[SYNC] - Copying backup to $OTHER_SERVER..."
  scp -r $BACKUP_FOLDER/$COLLECTION $OTHER_SERVER:$BACKUP_FOLDER/

  if [ ! $? -eq 0 ]; then
    echo "Something went wrong. Retrying..."
    scp -r $BACKUP_FOLDER/$COLLECTION $OTHER_SERVER:$BACKUP_FOLDER/
  fi
  if [ ! $? -eq 0 ]; then
    echo "ERROR - Something went wrong while copying files to $OTHER_SERVER! Aborting."
    exit 1
  fi

  echo "[SYNC] - Files copied successfully!"

}


# This is the delete step, it used to be called cleanup but was renamed because c was already used for the compress flag.
# I was lazy and didn't rename the variables & functions accordingly ¯\_(ツ)_/¯
cleanup() { 
  echo "[DELETE] - Starting delete step"

  INPUT_FOLDER=$(bash -c "find $BACKUP_FOLDER -mindepth 1 -maxdepth 1 -type d && echo $BACKUP_FOLDER/$COLLECTION" | sort | uniq -d)

  if [ -z "$INPUT_FOLDER" ]; then
    echo "ERROR - No collection named '$COLLECTION' found in $BACKUP_FOLDER. "
    exit 5
  fi

  echo "[DELETE] - Deleting original local files..."
  rm -rf $HADOOP_FOLDER/$COLLECTION


  echo "[DELETE] - Deleting original remote files..."
  ssh $OTHER_SERVER "rm -rf $HADOOP_FOLDER/$COLLECTION"
  if [ ! $? -eq 0 ]; then
    echo "Something went wrong. Retrying..."
    ssh $OTHER_SERVER "rm -rf $HADOOP_FOLDER/$COLLECTION"
  fi

  echo "[DELETE] - Done!"
}

unset -v COLLECTION
unset -v OTHER_SERVER

BACKUP=true
COMPRESS=true
SYNC=true
CLEANUP=true

while getopts "C:S:hbcsd" opt
do
  case $opt in
    C)
      COLLECTION="$OPTARG"
      ;;
    S)
      OTHER_SERVER="$OPTARG"
      ;;
    h)
      usage
      ;;
    b) #Backup flag
      COMPRESS=false
      SYNC=false
      CLEANUP=false
      ;;
    c) #Compress flag
      if $COMPRESS ; then
        BACKUP=false
        SYNC=false
        CLEANUP=false
      fi
      COMPRESS=true
      ;;
    s) #Sync flag
      if $SYNC ; then
        BACKUP=false
        COMPRESS=false
        CLEANUP=false
      fi
      SYNC=true
      ;;
    d) #Delete flag
      if $CLEANUP ; then
        BACKUP=false
        COMPRESS=false
        SYNC=false
      fi
      CLEANUP=true
      ;;
    \?)
      echo "Error: Invalid option -$OPTARG"
      usage
      ;;
    :)
      echo "Error: Option -$OPTARG requires an argument."
      usage
      ;;
  esac
done

check

if $BACKUP; then
  backup
fi

if $COMPRESS; then
  compress
fi

if $SYNC; then
  sync
fi

if $CLEANUP; then
  cleanup
fi
